<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Ubuntu常用设置和命令</title>
      <link href="/2024/12/01/Ubuntu%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/12/01/Ubuntu%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu常用设置和命令-📃"><a href="#Ubuntu常用设置和命令-📃" class="headerlink" title="Ubuntu常用设置和命令 📃"></a>Ubuntu常用设置和命令 📃</h1><hr><h2 id="一、更换镜像源为阿里镜像源"><a href="#一、更换镜像源为阿里镜像源" class="headerlink" title="一、更换镜像源为阿里镜像源"></a>一、更换镜像源为阿里镜像源</h2><h3 id="换源步骤-阿里源"><a href="#换源步骤-阿里源" class="headerlink" title="换源步骤 (阿里源)"></a>换源步骤 (阿里源)</h3><p>在 Ubuntu 24.04 之前，Ubuntu 的软件源配置文件使用传统的 One-Line-Style，路径为 <code>/etc/apt/sources.list</code>；从 Ubuntu 24.04 开始，Ubuntu 的软件源配置文件变更为 DEB822 格式，路径为 <code>/etc/apt/sources.list.d/ubuntu.sources</code>。</p><p><strong>注意：</strong> 24.04 源文件地址 已经更换为 <code>/etc/apt/sources.list.d/ubuntu.sources</code><br>以更换阿里源为例，受限打开终端，输入以下命令，备份当前的源列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list.d/ubuntu.sources  /etc/apt/sources.list.d/ubuntu.sources.bak</span><br></pre></td></tr></table></figure><p>打开文本编辑器，输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list.d/ubuntu.sources</span><br></pre></td></tr></table></figure><p>在文本编辑器中粘贴以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 阿里云</span><br><span class="line">Types: deb</span><br><span class="line">URIs: http://mirrors.aliyun.com/ubuntu/</span><br><span class="line">Suites: noble noble-updates noble-security</span><br><span class="line">Components: main restricted universe multiverse</span><br><span class="line">Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg</span><br></pre></td></tr></table></figure><p>保存并关闭文本编辑器。</p><p>更新源列表，输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>如果需要，可以更新系统软件包，输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><p>其他几份国内源如下：</p><h3 id="清华源"><a href="#清华源" class="headerlink" title="清华源"></a>清华源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">Types: deb</span><br><span class="line">URIs: http://mirrors.tuna.tsinghua.edu.cn/ubuntu/</span><br><span class="line">Suites: noble noble-updates noble-security</span><br><span class="line">Components: main restricted universe multiverse</span><br><span class="line">Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg</span><br></pre></td></tr></table></figure><h3 id="中科大源"><a href="#中科大源" class="headerlink" title="中科大源"></a>中科大源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Types: deb</span><br><span class="line">URIs: http://mirrors.ustc.edu.cn/ubuntu/</span><br><span class="line">Suites: noble noble-updates noble-security</span><br><span class="line">Components: main restricted universe multiverse</span><br><span class="line">Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg</span><br></pre></td></tr></table></figure><h3 id="网易163源"><a href="#网易163源" class="headerlink" title="网易163源"></a>网易163源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Types: deb</span><br><span class="line">URIs: http://mirrors.163.com/ubuntu/</span><br><span class="line">Suites: noble noble-updates noble-security</span><br><span class="line">Components: main restricted universe multiverse</span><br><span class="line">Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg</span><br></pre></td></tr></table></figure><h2 id="二、开启ssh服务，配置root远程登录"><a href="#二、开启ssh服务，配置root远程登录" class="headerlink" title="二、开启ssh服务，配置root远程登录"></a>二、开启ssh服务，配置root远程登录</h2><blockquote><p>注：自己根据自身情况决定加不加sudo </p></blockquote><h3 id="一、开启ssh服务"><a href="#一、开启ssh服务" class="headerlink" title="一、开启ssh服务"></a>一、开启ssh服务</h3><h4 id="1、先更新下载源"><a href="#1、先更新下载源" class="headerlink" title="1、先更新下载源"></a>1、先更新下载源</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt <span class="keyword">update</span></span><br></pre></td></tr></table></figure><blockquote><p>注：<code>apt upgrade</code>这个命令，会把本地已安装的软件，与刚下载的软件列表里对应软件地址的软件进行对比，如果发现已安装的软件版本太低，就会提示你更新。</p></blockquote><h4 id="2-安装ssh服务器"><a href="#2-安装ssh服务器" class="headerlink" title="2.安装ssh服务器"></a>2.安装ssh服务器</h4><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install openssh-<span class="built_in">server</span></span><br></pre></td></tr></table></figure><h4 id="3-启动ssh服务"><a href="#3-启动ssh服务" class="headerlink" title="3.启动ssh服务"></a>3.启动ssh服务</h4><h4 id="（1-输入下面的命令启动ssh服务"><a href="#（1-输入下面的命令启动ssh服务" class="headerlink" title="（1)输入下面的命令启动ssh服务"></a>（1)输入下面的命令启动ssh服务</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service ssh <span class="keyword">start</span></span><br></pre></td></tr></table></figure><h4 id="2-查看ssh服务是否开启"><a href="#2-查看ssh服务是否开启" class="headerlink" title="(2)查看ssh服务是否开启"></a>(2)查看ssh服务是否开启</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -e |<span class="keyword">grep</span> ssh</span><br></pre></td></tr></table></figure><p><strong>还可以通过下面这个命令查看ssh状态</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service ssh <span class="built_in">status</span></span><br></pre></td></tr></table></figure><p><strong>running即已启动</strong>，至此SSH服务已开启。</p><h3 id="二、配置root用户远程登录"><a href="#二、配置root用户远程登录" class="headerlink" title="二、配置root用户远程登录"></a>二、配置root用户远程登录</h3><h4 id="1-先下载vim编辑器"><a href="#1-先下载vim编辑器" class="headerlink" title="1.先下载vim编辑器"></a>1.先下载vim编辑器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install vim</span><br></pre></td></tr></table></figure><h4 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2.修改配置文件"></a>2.修改配置文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>在配置文件中加入一行: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PermitRootLogin <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/direct/52c88c2252444061a28f42bd7b28fec7.png" alt="img"></p><h4 id="3-重启SSH服务，完事"><a href="#3-重启SSH服务，完事" class="headerlink" title="3.重启SSH服务，完事"></a>3.重启SSH服务，完事</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service ssh restart</span><br></pre></td></tr></table></figure><blockquote><p>但高版本的ubuntu还是无法直接用ssh登录，需用普通用户登录，再用<code>sudo -i</code>切换至root用户。</p></blockquote><h2 id="三、添加系统字体"><a href="#三、添加系统字体" class="headerlink" title="三、添加系统字体"></a>三、添加系统字体</h2><blockquote><p>系统字体保存路径在<code>/usr/share/fonts</code>下，如果此目录下缺少字体，则使用其他可视化api（如Python的pygame库）的默认配置时可能会出现乱码问题。</p></blockquote><h3 id="方法一：手动添加字体文件"><a href="#方法一：手动添加字体文件" class="headerlink" title="方法一：手动添加字体文件"></a>方法一：手动添加字体文件</h3><ul><li>下载字体文件：从互联网下载你需要的字体文件（例如，.ttf 或 .otf 文件）。</li><li>复制字体文件到 /usr/local/share/fonts：将下载的字体文件复制到 /usr/local/share/fonts 目录。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /path/to/downloaded/font.ttf /usr/local/share/fonts/</span><br></pre></td></tr></table></figure><ul><li>更新字体缓存：添加字体后，运行 fc-cache 命令来更新字体缓存。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fc-cache -fv</span><br></pre></td></tr></table></figure><h3 id="方法二：通过系统包管理器安装字体"><a href="#方法二：通过系统包管理器安装字体" class="headerlink" title="方法二：通过系统包管理器安装字体"></a>方法二：通过系统包管理器安装字体</h3><p>Ubuntu 提供了多种字体包，可以通过 apt 包管理器安装。以下是一些常见的字体包：</p><ul><li>安装 Microsoft 字体：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install ttf-mscorefonts-installer</span><br></pre></td></tr></table></figure><ul><li>安装 Google 字体：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install fonts-noto</span><br></pre></td></tr></table></figure><ul><li>安装其他常用字体：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install fonts-dejavu</span><br><span class="line">sudo apt install fonts-liberation</span><br><span class="line">sudo apt install fonts-ubuntu</span><br></pre></td></tr></table></figure><p>安装这些字体包后，系统会自动将字体文件添加到合适的目录（通常是 <code>/usr/share/fonts</code>或<code>/usr/local/share/fonts</code>），并更新字体缓存。</p><h3 id="方法三：使用-fontconfig-来查找现有系统字体"><a href="#方法三：使用-fontconfig-来查找现有系统字体" class="headerlink" title="方法三：使用 fontconfig 来查找现有系统字体"></a>方法三：使用 fontconfig 来查找现有系统字体</h3><p>即使 <code>/usr/local/share/fonts</code> 目录中没有字体文件，系统其他位置仍然可能有字体文件。你可以使用 fontconfig 来查找这些字体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fc-list</span><br></pre></td></tr></table></figure><p>此命令会列出系统中所有可用的字体及其路径。你可以使用 grep 来查找特定的字体。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fc-list | grep -i &quot;arial&quot;</span><br></pre></td></tr></table></figure><h2 id="四、切换默认sh为bash或者dash"><a href="#四、切换默认sh为bash或者dash" class="headerlink" title="四、切换默认sh为bash或者dash"></a>四、切换默认sh为bash或者dash</h2><h3 id="1-bash与dash"><a href="#1-bash与dash" class="headerlink" title="1 bash与dash"></a>1 bash与dash</h3><hr><p>从Ubuntu 6.10开始，默认使用dash(theDebian Almquist Shell)而不是bash(the GNUBourne-Again Shell).</p><p>但Login Shell还是bash. 原因是dash更快、更高效，而且它符合POSIX规范。Ubuntu在启动的时候会运行很多shell脚本，使用dash可以加快启动速度。</p><h3 id="2-切换bash和dash"><a href="#2-切换bash和dash" class="headerlink" title="2 ﻿切换bash和dash"></a>2 ﻿切换bash和dash</h3><hr><h4 id="2-1-查看与使用"><a href="#2-1-查看与使用" class="headerlink" title="2.1 查看与使用"></a>2.1 查看与使用</h4><hr><p>先用命令<code>ls -l /bin/sh</code>看看</p><blockquote><p>/bin/sh -&gt; dash</p></blockquote><p>我们会发现Ubuntu默认采用的是 dash</p><h4 id="2-2-切换sh为bash"><a href="#2-2-切换sh为bash" class="headerlink" title="2.2 切换sh为bash"></a>2.2 切换sh为bash</h4><hr><p>查看shell是否为bash，在终端运行如下命令</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /bin/sh</span><br></pre></td></tr></table></figure><p>如果显示为“/bin/sh -&gt; bash”则为正常，否则请按以下方式修改：</p><p><strong>方法一</strong>：在终端运行如下命令，然后选择 no。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg-reconfigure dash</span><br></pre></td></tr></table></figure><p><strong>方法二</strong>：先删除sh，再创建软链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /bin/sh</span><br><span class="line">sudo ln -s /bin/bash /bin/sh</span><br></pre></td></tr></table></figure><h4 id="2-3-切换sh为dash"><a href="#2-3-切换sh为dash" class="headerlink" title="2.3 切换sh为dash"></a>2.3 切换sh为dash</h4><hr><p>当然我们也可以使用</p><blockquote><p>sudo dpkg-reconfigure dash</p></blockquote><p>把sh修改回去</p><h3 id="3-美化bash"><a href="#3-美化bash" class="headerlink" title="3.美化bash"></a>3.美化bash</h3><blockquote><p>默认用户和root用户分别进行如下操作</p></blockquote><h4 id="3-1打开配置文件"><a href="#3-1打开配置文件" class="headerlink" title="3.1打开配置文件"></a>3.1打开配置文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure><h4 id="3-2编辑配置文件"><a href="#3-2编辑配置文件" class="headerlink" title="3.2编辑配置文件"></a>3.2编辑配置文件</h4><p>打开后按i键，在文件最后添加如下美化代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PS1=&#x27;\[\e[37;1m\][\[\e[31;1m\]\u\[\e[34;1m\]@\[\e[32;1m\]\h \[\e[31;1m\]\w \[\e[33;1m\]\t\[\e[37;1m\]]\[\e[32;1m\]\$\[\e[m\]&#x27;</span><br></pre></td></tr></table></figure><p>PS1具体对应的美化教程参考：<a href="https://blog.csdn.net/kim5659/article/details/104514814">https://blog.csdn.net/kim5659/article/details/104514814</a></p><h4 id="3-3保存并应用配置文件"><a href="#3-3保存并应用配置文件" class="headerlink" title="3.3保存并应用配置文件"></a>3.3保存并应用配置文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言经典100例学习笔记</title>
      <link href="/2023/02/11/C%E8%AF%AD%E8%A8%80%E7%BB%8F%E5%85%B8100%E4%BE%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/02/11/C%E8%AF%AD%E8%A8%80%E7%BB%8F%E5%85%B8100%E4%BE%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言经典100例学习笔记"><a href="#C语言经典100例学习笔记" class="headerlink" title="C语言经典100例学习笔记"></a>C语言经典100例学习笔记</h1><blockquote><p>本文大部分内容转载自<a href="https://www.runoob.com/">菜鸟教程</a>,欢迎编程初学者访问学习！🌼</p></blockquote><h3 id="例题1-约瑟夫生者死者小游戏"><a href="#例题1-约瑟夫生者死者小游戏" class="headerlink" title="例题1. 约瑟夫生者死者小游戏"></a>例题1. 约瑟夫生者死者小游戏</h3><p><code>题目内容：</code>30个人在一条船上，超载，需要15人下船。于是人们排成一队，排队的位置即为他们的编号。报数，从1开始，数到9的人下船。如此循环，直到船上仅剩15人为止，问都有哪些编号的人下船了呢？</p><p><code>解题关键：</code></p><ul><li>转变思路，对在船上和下船的赋予状态，例如：在船上的人的状态为0，下船的人的状态为1；</li><li>报数到第10个人时，报数重新变为1，这是循环初始化的一个过程；</li><li>每个人所在的位置（或编号）是固定不变的，即使某个人下船了，他所在的位置在计数时也要算上，这样计数到31时,重新初始化为1，所有人的编号不会发生变化，实现船头和船尾的人连接。</li></ul><p><code>示例代码</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> state[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 将每个人状态初始化为0，表示在船上</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;       <span class="comment">// 报数</span></span><br><span class="line">    <span class="type">int</span> down = <span class="number">0</span>;        <span class="comment">// 计下船的人数</span></span><br><span class="line">    <span class="type">int</span> people = <span class="number">1</span>;      <span class="comment">// 人的编号</span></span><br><span class="line">    <span class="keyword">while</span> (down &lt; <span class="number">15</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (people == <span class="number">31</span>) <span class="comment">// 计数到31时,重新初始化为1，所有人的编号在进行到下一轮时将不会发生变化</span></span><br><span class="line">        &#123;</span><br><span class="line">            people = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (state[people - <span class="number">1</span>] == <span class="number">0</span>) <span class="comment">// 减1是因为索引值是从0开始，且这个人仍在船上时参与报数</span></span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">10</span>) <span class="comment">// 报数到第10个人时，重新初始化为1进行下一轮报数</span></span><br><span class="line">            &#123;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">                state[people - <span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 报9的倍数的那个人的状态变为1，不参与下次报数，下船人数+1</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;第%d号下船了\n&quot;</span>, people);</span><br><span class="line">                down++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        people++; <span class="comment">// 不管这个人是否还在船上，每个人的位置固定不变，编号是从1~30递增的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;留在船上的人的编号为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) <span class="comment">// 遍历30个人的状态，当为0的时候，表示还在船上，依次输出</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (state[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%-3d&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>运行结果</code>：</p><p><img src="C语言经典100例学习笔记/image-20230211184931728.png" alt="例题1运行结果"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 经典100例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/02/11/hello-world/"/>
      <url>/2023/02/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 经典100例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习笔记</title>
      <link href="/2023/01/26/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/26/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="算法学习笔记-🌄"><a href="#算法学习笔记-🌄" class="headerlink" title="算法学习笔记 🌄"></a>算法学习笔记 🌄</h1><hr><pre><code>**算法**一词代指解决问题的方法，换句话说，算法提供了一整套解决问题的方案或者思路，即先做什么，再做什么，最后做什么。学习算法，可以短时间内快速提升我们“遇到问题，解决问题”的能力。</code></pre><blockquote><p>笔记大部分内容和图例转载自<a href="http://c.biancheng.net/">C语言中文网</a>，感谢站长的付出。</p></blockquote><h2 id="一、基础算法"><a href="#一、基础算法" class="headerlink" title="一、基础算法"></a>一、基础算法</h2><h3 id="（一）二分查找"><a href="#（一）二分查找" class="headerlink" title="（一）二分查找"></a>（一）二分查找</h3><ul><li><code>定义</code>：二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用<a href="https://baike.baidu.com/item/顺序存储结构/1347176?fromModule=lemma_inlink">顺序存储结构</a>，而且表中元素按索引有序排列。</li><li><code>局限性</code>：1. Sorted（单调递增或者递减）；2. Bounded（存在上下边界）；3. Accessible by index（能够通过索引访问）。</li><li><code>算法复杂度</code>：二分查找的基本思想是将n个元素分成大致相等的两部分，取a[n/2]与x(目标值)做比较，如果x=a[n/2],则找到x,算法中止；如果x<a[n/2],则只要在数组a的左半部分继续搜索x,如果x>a[n/2],则只要在数组a的右半部搜索x。</li><li><code>伪代码</code>：如下用给大家展示了二分查找算法的具体实现过程：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入 arr<span class="punctuation">[</span><span class="punctuation">]</span>                                    <span class="comment">// 输入有序序列</span></span><br><span class="line">binary_search( arr <span class="punctuation">,</span> begin <span class="punctuation">,</span> end <span class="punctuation">,</span> target)<span class="punctuation">:</span>  <span class="comment">// [begin,end]指定搜索区域，target为要搜索的目标元素</span></span><br><span class="line">    if begin &gt; end<span class="punctuation">:</span>                          <span class="comment">// [begin,end]不存在时，返回一个错误值（比如-1）</span></span><br><span class="line">        return <span class="number">-1</span></span><br><span class="line">    mid &lt;- ⌊ begin+(end-begin)/<span class="number">2</span> ⌋           <span class="comment">// 找到[begin,end]区域内中间元素所在位置的下标</span></span><br><span class="line">    if target == arr<span class="punctuation">[</span>mid<span class="punctuation">]</span><span class="punctuation">:</span>                   <span class="comment">// 递归的出口，即target和中间元素的值相等</span></span><br><span class="line">        return mid</span><br><span class="line">    if target ＜ arr<span class="punctuation">[</span>mid<span class="punctuation">]</span><span class="punctuation">:</span>                   <span class="comment">// 比较target和中间元素的值，进一步缩小搜索区域</span></span><br><span class="line">        return binary_search(arr <span class="punctuation">,</span> begin <span class="punctuation">,</span> mid<span class="number">-1</span> <span class="punctuation">,</span> target)</span><br><span class="line">    else<span class="punctuation">:</span></span><br><span class="line">        return binary_search(arr <span class="punctuation">,</span> mid+<span class="number">1</span> <span class="punctuation">,</span> end <span class="punctuation">,</span> target)</span><br></pre></td></tr></table></figure><ul><li><code>示例代码</code>:C语言用二分查找算法找出目标值索引的示例代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary_search</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> mid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (left &gt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 如果[left,right] 不存在，返回 -1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 找到中间元素所在的位置,使用(left+right)/2会有整数溢出的问题问题会出现在当left+right的结果大于表达式结果类型所能表示的最大值时，这样，产生溢出后再除2是不会产生正确结果的，而left + (right - left) / 2不存在这个问题 */</span></span><br><span class="line">mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (target == arr[mid])  <span class="comment">// 递归的出口</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (target &lt; arr[mid])  <span class="comment">// 比较 target 和 arr[mid] 的值，缩小 target 可能存在的区域</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">binary_search</span>(arr, left, mid - <span class="number">1</span>, target);  <span class="comment">// 新的搜索区域为 [left,mid-1]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">binary_search</span>(arr, mid + <span class="number">1</span>, right, target);  <span class="comment">// 新的搜索区域为 [mid+1,right]</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary_search</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span></span>;</span><br><span class="line"><span class="type">int</span> Array[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">19</span>&#125;;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">sizeof</span>(Array) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> target;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Array[10] = &#123;1, 4, 7, 8, 9, 12, 13, 16, 18, 19&#125;\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;在上面数组中挑一个数输入按回车键，可查找其索引值：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;target);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;索引值为%d\n&quot;</span>, <span class="built_in">binary_search</span>(Array, left, right, target));</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（二）分治算法"><a href="#（二）分治算法" class="headerlink" title="（二）分治算法"></a>（二）分治算法</h3><ul><li><p><code>定义</code>：“分治”即“分而治之”的意思。分治算法解决问题的思路是：先将整个问题拆分成多个相互独立且数据量更少的小问题，通过逐一解决这些简单的小问题，最终找到解决整个问题的方案。</p><blockquote><p>所谓问题间相互独立，简单理解就是每个问题都可以单独处理，不存在“谁先处理，谁后处理”的次序问题。</p></blockquote></li><li><p><code>局限性</code>:使用分治算法解决的问题都具备这样的特征，当需要处理的数据量很少时，问题很容易就能解决，随着数据量增多，问题的解决难度也随之增大。</p><p>分治算法的弊端也很明显，该算法经常和递归算法搭配使用，整个解决问题的过程会耗费较多的时间和内存空间，严重时还可能导致程序运行崩溃。</p></li><li><p><code>示例图</code>：分治算法找数组的最大值和最小值：不断地等分数组中的元素，直至各个分组中元素的个数 ≤2。由于每个分组内的元素最多有 2 个，很容易就可以找出其中的最值（最大值或最小值），然后这些最值再进行两两比较，最终找到的最值就是整个数组中的最值。下图展示了用分治算法查找 {3, 7, 2, 1} 中最大值的实现过程：</p><p><img src="算法学习笔记/fenzhisuanfa.gif" alt="分治算法"></p></li><li><code>伪代码</code>：如下是分治算法求数组中最大值的:</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入 arr<span class="punctuation">[</span><span class="number">1.</span>..n<span class="punctuation">]</span>            <span class="comment">// 输入n个数字</span></span><br><span class="line">arr_max(x <span class="punctuation">,</span> y) <span class="punctuation">:</span>          <span class="comment">// 设计一个递归函数，[x,y] 用来限定查找最大数的范围</span></span><br><span class="line">    if y-x ≤ <span class="number">1</span> <span class="punctuation">:</span>          <span class="comment">// 如果y-x的值小于等于1，则比较 arr[x]和arr[y]的值，大的就是最大值 </span></span><br><span class="line">        return max(arr<span class="punctuation">[</span>x<span class="punctuation">]</span> <span class="punctuation">,</span> arr<span class="punctuation">[</span>y<span class="punctuation">]</span>)</span><br><span class="line">    else <span class="punctuation">:</span></span><br><span class="line">    <span class="comment">// 将[x,y]区域划分为[x,⌊(x+y)/2⌋ ]和[⌊(x+y)/2+1⌋,y] 两个区域，求出两个区域内各自的最大值</span></span><br><span class="line">        max1 = arr_max(x <span class="punctuation">,</span> ⌊(x+y)/<span class="number">2</span>⌋ )  </span><br><span class="line">        max2 = arr_max( ⌊(x+y)/<span class="number">2</span>+<span class="number">1</span>⌋ <span class="punctuation">,</span> y)</span><br><span class="line">    return max(max1 <span class="punctuation">,</span> max2)   <span class="comment">// 比较两个区域的最大值，最终找出[x,y] 中的最大值</span></span><br></pre></td></tr></table></figure><ul><li><code>示例代码</code>：C语言用分治算法实现“求数组中最大值”的代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_max</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> max_left = <span class="number">0</span>, max_right = <span class="number">0</span>, middle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 如果数组不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right - left == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[left];  <span class="comment">// 如果查找范围中仅有一个数字</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right - left &lt;= <span class="number">1</span>)  <span class="comment">// 如果查找范围中有 2 个数字，直接比较即可</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[left] &gt;= arr[right])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[right];</span><br><span class="line">    &#125;</span><br><span class="line">    middle = (right - left) / <span class="number">2</span> + left;  <span class="comment">// 等量划分成 2 个区域</span></span><br><span class="line">    max_left = <span class="built_in">get_max</span>(arr, left, middle);  <span class="comment">// 得到左侧区域中的最大值</span></span><br><span class="line">    max_right = <span class="built_in">get_max</span>(arr, middle + <span class="number">1</span>, right);  <span class="comment">// 得到右侧区域中的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (max_left &gt;= max_right)    <span class="comment">// 比较左、右两侧的最大值，找到 [left,right] 整个区域的最大值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> max_left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> max_right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_max</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>;</span><br><span class="line">    <span class="type">int</span> Arr[<span class="number">6</span>] = &#123;<span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">get_max</span>(Arr, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, result);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（三）排序算法"><a href="#（三）排序算法" class="headerlink" title="（三）排序算法"></a>（三）排序算法</h3><h4 id="◆-桶排序"><a href="#◆-桶排序" class="headerlink" title="◆ 桶排序"></a><strong>◆ 桶排序</strong></h4><ul><li><code>定义</code>：桶排序（又称箱排序）是一种基于分治思想、效率很高的排序算法。</li><li><p><code>思路</code>：假设一种场景，对 {5, 2, 1, 4, 3} 进行升序排序，桶排序算法的实现思路是：</p><p>  1.准备5个桶，从1~5对它们进行编号；</p><p>  2.将待排序序列的各个元素放置到相同编号的桶中；</p><p>  3.从1号桶开始，依次获取桶中放置的元素，得到的就是一个升序序列。</p></li><li><p><code>时间复杂度</code>：理想情况下对应的时间复杂度为O(n)。</p></li><li><code>示例代码</code>：只有一种元素的情况下，C语言桶排序示例代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 101 <span class="comment">// 0~100内的整数，则需要101个桶</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, t;</span><br><span class="line">    <span class="type">int</span> mark[NUM];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= NUM - <span class="number">1</span>; i++) <span class="comment">// 0~100号标记桶，初始化为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        mark[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入需要排序的个数：&quot;</span>); <span class="comment">// 表示接下来有n个数排序</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入%d个0~100的整数：\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t); <span class="comment">// 此处是关键，对输入的数，找到对应的桶进行标记和计数</span></span><br><span class="line">        mark[t]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从小到大排序结果为：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= NUM - <span class="number">1</span>; i++) <span class="comment">// 遍历全部桶，每个桶计数为多少，就输出多少次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= mark[i]; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%-3d&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从大到小排序结果为：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = NUM - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= mark[i]; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%-3d&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="◆-冒泡排序"><a href="#◆-冒泡排序" class="headerlink" title="◆ 冒泡排序"></a><strong>◆ 冒泡排序</strong></h4><ul><li><code>定义</code>：冒泡排序(Bubble_sort)是所有排序算法中最简单、最易实现的算法，有时也称为==起泡排序==算法。使用冒泡排序算法对n个数据进行排序。</li><li><code>思路</code>：从待排序序列中找出一个最大值或最小值，这样的操作执行n-1次，最终就可以得到一个有序序列。</li><li><code>时间复杂度</code>:（n-1）^2^，记为O(n^2^)。</li><li><code>伪代码</code>：如下是冒泡排序算法实现升序排序：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Bubble_sort(list)<span class="punctuation">:</span>                <span class="comment">//list表示待排序序列</span></span><br><span class="line">    for i &lt;- <span class="number">0</span> to length(list)<span class="number">-1</span><span class="punctuation">:</span> <span class="comment">//对元素个数为n的list序列，需遍历n-1次，这里用[0,length(list)-1)表示</span></span><br><span class="line">        for j &lt;- <span class="number">1</span> to length(list) - i<span class="punctuation">:</span>    <span class="comment">// 从第1个元素开始遍历，遍历区间为[1,length(list)-i)</span></span><br><span class="line">            if list<span class="punctuation">[</span>j<span class="punctuation">]</span> &gt; list<span class="punctuation">[</span>j+<span class="number">1</span><span class="punctuation">]</span><span class="punctuation">:</span>        <span class="comment">// 若进行降序排序，则改成&lt;小于号</span></span><br><span class="line">                 swap(list<span class="punctuation">[</span>j<span class="punctuation">]</span> <span class="punctuation">,</span> list<span class="punctuation">[</span>j+<span class="number">1</span><span class="punctuation">]</span>) <span class="comment">// 交换2个相邻元素的位置</span></span><br><span class="line">    return list                            <span class="comment">// 返回排好序的序列</span></span><br></pre></td></tr></table></figure><ul><li><code>示例代码</code>：C语言冒泡排序降序示例代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bubble_sort</span><span class="params">(<span class="type">int</span> *array, <span class="type">int</span> n)</span> <span class="comment">//实现冒泡降序排序算法的函数，array为待排序数组，n为数组元素个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) <span class="comment">//n个元素，遍历n-1次，相邻两数两两向后遍历，n个数只需遍历n-1次就行</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++)  <span class="comment">// 从第1个元素开始遍历，遍历至n-1-i</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &lt; array[j + <span class="number">1</span>]) <span class="comment">//比较相邻两数的大小，进行元素位置交换</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp = array[j];</span><br><span class="line">                array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                array[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Bubble_sort</span><span class="params">(<span class="type">int</span> *array, <span class="type">int</span> n)</span></span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入排序的元素个数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> *array = (<span class="type">int</span> *)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入%d个数进行排序：&quot;</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Bubble_sort</span>(array, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-3d&quot;</span>, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(array);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（四）递归算法"><a href="#（四）递归算法" class="headerlink" title="（四）递归算法"></a>（四）递归算法</h3><ul><li><code>定义</code>：将函数（方法）调用自身的过程称为递归，调用自身的函数称为递归函数，用递归方式解决问题的算法称为递归算法。涉及==栈==的知识，即“先进后出”。下图展示了函数递归调用的底层实现过程：</li></ul><p><img src="算法学习笔记/2-210R0095J2591.gif" alt="递归的底层实现"></p><ul><li><code>局限性</code>：设计递归函数时，我们必须为它设置一个结束递归的“出口”，否则函数会一直调用自身（死循环），直至运行崩溃。</li><li><code>伪代码</code>：分两种情况==直接调用==和==间接调用==：</li></ul><blockquote><p>直接调用自身</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int funciton(<span class="comment">/*...*/</span>) <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//调用自身</span></span><br><span class="line">    function(<span class="comment">/*...*/</span>);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>间接调用自身</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int funciton1(<span class="comment">/*...*/</span>) <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//调用另一个函数</span></span><br><span class="line">    function2(<span class="comment">/*...*/</span>);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">int function2(<span class="comment">/*...*/</span>) <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//调用function1()函数</span></span><br><span class="line">    funciton1(<span class="comment">/*...*/</span>);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>示例代码</code>：C语言递归算法求 <code>n!</code>示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">0</span>) <span class="comment">// 递归的出口</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n - <span class="number">1</span>); <span class="comment">// 函数调用自身</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入一个数，求阶乘值：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d! = %d\n&quot;</span>, n, <span class="built_in">factorial</span>(n));</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（五）贪心算法"><a href="#（五）贪心算法" class="headerlink" title="（五）贪心算法"></a>（五）贪心算法</h3><ul><li><code>定义</code>：每一步都力求最大限度地解决问题，每一步都选择的是当前最优的解决方案，这种解决问题的算法就是贪心算法。</li><li><code>局限性</code>：虽然贪心算法每一步都是最优的解决方案，但整个算法并不一定是最优的。总的来讲，贪心算法注重的是每一步选择最优的解决方案（又称“局部最优解”），并不关心整个解决方案是否最优。</li><li><code>示例代码</code>：C语言谈心算法求==小孩分糖==问题示例代码如下：</li></ul><blockquote><p>题目引用自LeetCode<a href="https://leetcode.cn/problems/assign-cookies/">第455题</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bubble_sort</span><span class="params">(<span class="type">int</span> *array, <span class="type">int</span> lenth)</span> <span class="comment">// 排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; lenth - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; lenth - i - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                temp = array[j];</span><br><span class="line">                array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                array[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_target</span><span class="params">(<span class="type">int</span> *child, <span class="type">int</span> child_len, <span class="type">int</span> *candy, <span class="type">int</span> candy_len)</span> <span class="comment">// 计算满足小孩需求的最大数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Bubble_sort</span>(child, child_len);  <span class="comment">// 小孩需求从小到大排序</span></span><br><span class="line">    <span class="built_in">Bubble_sort</span>(candy, candy_len);  <span class="comment">// 糖果大小从小到大排序</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;                      <span class="comment">// 小孩需求索引</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;                      <span class="comment">// 糖果索引</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; child_len &amp;&amp; j &lt; candy_len) <span class="comment">// 糖果和小孩都没有完成尝试时，循环进行</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (candy[j] &gt;= child[i]) <span class="comment">// 小孩需求被满足时剔除，让下一个小孩继续尝试</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;  <span class="comment">// 糖果无论小孩需求满足与否，糖果都要逐个剔除</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Bubble_sort</span><span class="params">(<span class="type">int</span> *array, <span class="type">int</span> lenth)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find_target</span><span class="params">(<span class="type">int</span> *child, <span class="type">int</span> child_len, <span class="type">int</span> *candy, <span class="type">int</span> candy_len)</span></span>;</span><br><span class="line">    <span class="type">int</span> child[<span class="number">6</span>] = &#123;<span class="number">6</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">16</span>, <span class="number">10</span>&#125;;     <span class="comment">// 小孩需求大小</span></span><br><span class="line">    <span class="type">int</span> candy[<span class="number">5</span>] = &#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">21</span>, <span class="number">4</span>, <span class="number">9</span>&#125;;           <span class="comment">// 糖果大小</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大可满足%d个小孩的需求\n&quot;</span>, <span class="built_in">find_target</span>(child, <span class="number">6</span>, candy, <span class="number">5</span>));</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
